package manager

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	// Import parser
	"github.com/bash-shortcuts/ah/pkg/parser"
)

// CompileAliases merges all active alias files into a single sourceable file
func CompileAliases() error {
	root, err := GetRootDir()
	if err != nil {
		return err
	}

	activeDir := filepath.Join(root, ActiveDir)
	entries, err := os.ReadDir(activeDir)
	if err != nil {
		// No active dir? Just empty the file
		return writeCompiledFile(root, "")
	}

	var sb strings.Builder
	sb.WriteString("# Auto-generated alias dump by ah\n")
	sb.WriteString("# Do not edit this file directly.\n\n")

	for _, entry := range entries {
		aliasPath := filepath.Join(activeDir, entry.Name(), "alias.sh")
		if _, err := os.Stat(aliasPath); err == nil {

			// STRICT SANITIZATION:
			// Parse the file to find *only* alias definitions.
			// Ignore any other shell code (malware protection).
			aliases, err := parser.ParseAliases(aliasPath)
			if err != nil {
				// If parse fails, weird, but let's log and skip
				fmt.Printf("Warning: Failed to parse %s: %v\n", entry.Name(), err)
				continue
			}

			if len(aliases) > 0 {
				sb.WriteString(fmt.Sprintf("# Package: %s\n", entry.Name()))
				for _, a := range aliases {
					// Re-quote safely: val -> 'val' (escape single quotes)
					safeVal := strings.ReplaceAll(a.Command, "'", "'\\''")
					sb.WriteString(fmt.Sprintf("alias %s='%s'\n", a.Name, safeVal))
				}
				sb.WriteString("\n")
			}
		}
	}

	return writeCompiledFile(root, sb.String())
}

func writeCompiledFile(root, content string) error {
	dumpPath := filepath.Join(root, "aliases.compiled.sh")
	return os.WriteFile(dumpPath, []byte(content), 0644)
}
